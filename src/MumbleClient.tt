<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
    var rgx = new Regex(@"^message (\w+?) {$");
    var fileName = this.Host.ResolvePath(@"Messages\Mumble.proto");
    var messages = File.ReadLines(fileName)
                        .Select(l => rgx.Match(l))
                        .Where(r => r.Success)
                        .Select(r => r.Groups[1]);
#>
// <auto-generated />

namespace Mumble
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using Google.ProtocolBuffers;

    /// <summary>
    /// Generated partial class which contains all the events which MumbleClient throws
    /// when it receives events
    /// </summary>
    public sealed partial class MumbleClient
    {
        /// <summary>
        /// Mapping from concrete message type to a closure which will raise the appropriate event
        /// </summary>
        [GeneratedCode("T4", "1.0")]
        private Dictionary<Type, Action<MumbleClient, IMessage>> messageEventHandlers = new Dictionary<Type, Action<MumbleClient, IMessage>>
        {
<# foreach (var message in messages) { #>
            { typeof(Messages.<#= message #>), (sender, message) => sender.<#= message #>Received.RaiseEvent(sender, message) },
<# } #>
        };

        #region Event Handlers
<# foreach (var message in messages) { #>
        /// <summary>
        /// Fires when the client receives a <see cref="Messages.<#= message #>" /> message.
        /// </summary>
        [GeneratedCode("T4", "1.0")]
        internal event EventHandler<MessageReceivedEventArgs<Messages.<#= message #>>> <#= message #>Received;

<# } #>
        #endregion
    }
}